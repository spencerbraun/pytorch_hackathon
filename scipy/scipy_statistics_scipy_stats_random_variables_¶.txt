scipy_statistics_scipy_stats
Statistics (scipy.stats)
stats.html
 Random variables  There are two general distribution classes that have been implemented for encapsulating continuous random variables and discrete random variables . Over 80 continuous random variables (RVs) and 10 discrete random variables have been implemented using these classes. Besides this, new routines and distributions can be easily added by the end user. (If you create one, please contribute it.) All of the statistics functions are located in the sub-package scipy.stats and a fairly complete listing of these functions can be obtained using . The list of the random variables available can also be obtained from the docstring for the stats sub-package. In the discussion below, we mostly focus on continuous RVs. Nearly everything also applies to discrete variables, but we point out some differences here: Specific points for discrete distributions . In the code samples below, we assume that the scipy.stats package is imported as and in some cases we assume that individual objects are imported as Getting help  First of all, all distributions are accompanied with help functions. To obtain just some basic information, we print the relevant docstring: . To find the support, i.e., upper and lower bounds of the distribution, call: We can list all methods and properties of the distribution with . As it turns out, some of the methods are private, although they are not named as such (their names do not start with a leading underscore), for example , are only available for internal calculation (those methods will give warnings when one tries to use them, and will be removed at some point). To obtain the real main methods, we list the methods of the frozen distribution. (We explain the meaning of a frozen distribution below). Finally, we can obtain the list of available distribution through introspection: Common methods  The main public methods for continuous RVs are: rvs: Random Variates pdf: Probability Density Function cdf: Cumulative Distribution Function sf: Survival Function (1-CDF) ppf: Percent Point Function (Inverse of CDF) isf: Inverse Survival Function (Inverse of SF) stats: Return mean, variance, (Fisher’s) skew, or (Fisher’s) kurtosis moment: non-central moments of the distribution Let’s take a normal RV as an example. To compute the at a number of points, we can pass a list or a numpy array. Thus, the basic methods, such as pdf , cdf , and so on, are vectorized. Other generally useful methods are supported too: To find the median of a distribution, we can use the percent point function , which is the inverse of the : To generate a sequence of random variates, use the keyword argument: Note that drawing random numbers relies on generators from numpy.random package. In the example above, the specific stream of random numbers is not reproducible across runs. To achieve reproducibility, you can explicitly seed a global variable Relying on a global state is not recommended, though. A better way is to use the random_state parameter, which accepts an instance of numpy.random.RandomState class, or an integer, which is then used to seed an internal object: Don’t think that generates 5 variates: Here, with no keyword is being interpreted as the first possible keyword argument, , which is the first of a pair of keyword arguments taken by all continuous distributions. This brings us to the topic of the next subsection. Shifting and scaling  All continuous distributions take and as keyword parameters to adjust the location and scale of the distribution, e.g., for the standard normal distribution, the location is the mean and the scale is the standard deviation. In many cases, the standardized distribution for a random variable is obtained through the transformation . The default values are and . Smart use of and can help modify the standard distributions in many ways. To illustrate the scaling further, the of an exponentially distributed RV with mean is given by \[F(x)  1 - \exp(-\lambda x)\] By applying the scaling rule above, it can be seen that by taking we get the proper scale. Note Distributions that take shape parameters may require more than simple application of and/or to achieve the desired form. For example, the distribution of 2-D vector lengths given a constant vector of length perturbed by independent N(0, ) deviations in each component is rice( , scale ). The first argument is a shape parameter that needs to be scaled along with . The uniform distribution is also interesting: Finally, recall from the previous paragraph that we are left with the problem of the meaning of . As it turns out, calling a distribution like this, the first argument, i.e., the 5, gets passed to set the parameter. Let’s see: Thus, to explain the output of the example of the last section: generates a single normally distributed random variate with mean , because of the default . We recommend that you set and parameters explicitly, by passing the values as keywords rather than as arguments. Repetition can be minimized when calling more than one method of a given RV by using the technique of Freezing a Distribution , as explained below. Shape parameters  While a general continuous random variable can be shifted and scaled with the and parameters, some distributions require additional shape parameters. For instance, the gamma distribution with density \[\gamma(x, a)  \frac{\lambda (\lambda x)^{a-1}}{\Gamma(a)} e^{-\lambda x}\;,\] requires the shape parameter . Observe that setting can be obtained by setting the keyword to . Let’s check the number and name of the shape parameters of the gamma distribution. (We know from the above that this should be 1.) Now, we set the value of the shape variable to 1 to obtain the exponential distribution, so that we compare easily whether we get the results we expect. Notice that we can also specify shape parameters as keywords: Freezing a distribution  Passing the and keywords time and again can become quite bothersome. The concept of freezing a RV is used to solve such problems. By using we no longer have to include the scale or the shape parameters anymore. Thus, distributions can be used in one of two ways, either by passing all distribution parameters to each method call (such as we did earlier) or by freezing the parameters for the instance of the distribution. Let us check this: This is, indeed, what we should get. Broadcasting  The basic methods , and so on, satisfy the usual numpy broadcasting rules. For example, we can calculate the critical values for the upper tail of the t distribution for different probabilities and degrees of freedom. Here, the first row contains the critical values for 10 degrees of freedom and the second row for 11 degrees of freedom (d.o.f.). Thus, the broadcasting rules give the same result of calling twice: If the array with probabilities, i.e., and the array of degrees of freedom i.e., , have the same array shape, then element-wise matching is used. As an example, we can obtain the 10% tail for 10 d.o.f., the 5% tail for 11 d.o.f. and the 1% tail for 12 d.o.f. by calling Specific points for discrete distributions  Discrete distributions have mostly the same basic methods as the continuous distributions. However is replaced by the probability mass function , no estimation methods, such as fit, are available, and is not a valid keyword parameter. The location parameter, keyword , can still be used to shift the distribution. The computation of the cdf requires some extra attention. In the case of continuous distribution, the cumulative distribution function is, in most standard cases, strictly monotonic increasing in the bounds (a,b) and has, therefore, a unique inverse. The cdf of a discrete distribution, however, is a step function, hence the inverse cdf, i.e., the percent point function, requires a different definition: For further info, see the docs here . We can look at the hypergeometric distribution as an example If we use the cdf at some integer points and then evaluate the ppf at those cdf values, we get the initial integers back, for example If we use values that are not at the kinks of the cdf step function, we get the next higher integer back: Fitting distributions  The main additional methods of the not frozen distribution are related to the estimation of distribution parameters: fit: maximum likelihood estimation of distribution parameters, including location and scale fit_loc_scale: estimation of location and scale when shape parameters are given nnlf: negative log likelihood function expect: calculate the expectation of a function against the pdf or pmf Performance issues and cautionary remarks  The performance of the individual methods, in terms of speed, varies widely by distribution and method. The results of a method are obtained in one of two ways: either by explicit calculation, or by a generic algorithm that is independent of the specific distribution. Explicit calculation, on the one hand, requires that the method is directly specified for the given distribution, either through analytic formulas or through special functions in or for . These are usually relatively fast calculations. The generic methods, on the other hand, are used if the distribution does not specify any explicit calculation. To define a distribution, only one of pdf or cdf is necessary; all other methods can be derived using numeric integration and root finding. However, these indirect methods can be very slow. As an example, creates random variables in a very indirect way and takes about 19 seconds for 100 random variables on my computer, while one million random variables from the standard normal or from the t distribution take just above one second. Remaining issues  The distributions in have recently been corrected and improved and gained a considerable test suite; however, a few issues remain: The distributions have been tested over some range of parameters; however, in some corner ranges, a few incorrect results may remain. The maximum likelihood estimation in fit does not work with default starting parameters for all distributions and the user needs to supply good starting parameters. Also, for some distribution using a maximum likelihood estimator might inherently not be the best choice. 