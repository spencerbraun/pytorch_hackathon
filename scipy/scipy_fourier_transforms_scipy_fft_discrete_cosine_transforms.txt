scipy_fourier_transforms_scipy_fft
Fourier Transforms (scipy.fft)
fft.html
 Discrete Cosine Transforms  SciPy provides a DCT with the function dct and a corresponding IDCT with the function idct . There are 8 types of the DCT [WPC] , [Mak] ; however, only the first 3 types are implemented in scipy. “The” DCT generally refers to DCT type 2, and “the” Inverse DCT generally refers to DCT type 3. In addition, the DCT coefficients can be normalized differently (for most types, scipy provides and ). Two parameters of the dct/idct function calls allow setting the DCT type and coefficient normalization. For a single dimension array x, dct(x, norm’ortho’) is equal to MATLAB dct(x). Type I DCT  SciPy uses the following definition of the unnormalized DCT-I ( ): \[y[k]  x_0 + (-1)^k x_{N-1} + 2\sum_{n1}^{N-2} x[n] \cos\left(\frac{\pi nk}{N-1}\right), \qquad 0 \le k < N.\] Note that the DCT-I is only supported for input size > 1. Type II DCT  SciPy uses the following definition of the unnormalized DCT-II ( ): \[y[k]  2 \sum_{n0}^{N-1} x[n] \cos \left({\pi(2n+1)k \over 2N} \right) \qquad 0 \le k < N.\] In case of the normalized DCT ( ), the DCT coefficients are multiplied by a scaling factor f : \[\begin{split}f  \begin{cases} \sqrt{1/(4N)}, & \text{if $k  0$} \\ \sqrt{1/(2N)}, & \text{otherwise} \end{cases} \, .\end{split}\] In this case, the DCT “base functions” become orthonormal: \[\sum_{n0}^{N-1} \phi_k[n] \phi_l[n]  \delta_{lk}.\] Type III DCT  SciPy uses the following definition of the unnormalized DCT-III ( ): \[y[k]  x_0 + 2 \sum_{n1}^{N-1} x[n] \cos\left({\pi n(2k+1) \over 2N}\right) \qquad 0 \le k < N,\] or, for : \[y[k]  {x_0\over\sqrt{N}} + {2\over\sqrt{N}} \sum_{n1}^{N-1} x[n] \cos\left({\pi n(2k+1) \over 2N}\right) \qquad 0 \le k < N.\] DCT and IDCT  The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up to a factor of 2N . The orthonormalized DCT-III is exactly the inverse of the orthonormalized DCT- II. The function idct performs the mappings between the DCT and IDCT types, as well as the correct normalization. The following example shows the relation between DCT and IDCT for different types and normalizations. The DCT-II and DCT-III are each other’s inverses, so for an orthonormal transform we return back to the original signal. Doing the same under default normalization, however, we pick up an extra scaling factor of since the forward transform is unnormalized. For this reason, we should use the function idct using the same type for both, giving a correctly normalized result. Analogous results can be seen for the DCT-I, which is its own inverse up to a factor of . And for the DCT-IV, which is also its own inverse up to a factor of . Example  The DCT exhibits the “energy compaction property”, meaning that for many signals only the first few DCT coefficients have significant magnitude. Zeroing out the other coefficients leads to a small reconstruction error, a fact which is exploited in lossy signal compression (e.g. JPEG compression). The example below shows a signal x and two reconstructions ( and ) from the signal’s DCT coefficients. The signal is reconstructed from the first 20 DCT coefficients, is reconstructed from the first 15 DCT coefficients. It can be seen that the relative error of using 20 coefficients is still very small (~0.1%), but provides a five-fold compression rate. 