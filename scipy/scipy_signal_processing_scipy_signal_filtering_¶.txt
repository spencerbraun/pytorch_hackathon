scipy_signal_processing_scipy_signal
Signal Processing (scipy.signal)
signal.html
 Filtering  Filtering is a generic name for any system that modifies an input signal in some way. In SciPy, a signal can be thought of as a NumPy array. There are different kinds of filters for different kinds of operations. There are two broad kinds of filtering operations: linear and non-linear. Linear filters can always be reduced to multiplication of the flattened NumPy array by an appropriate matrix resulting in another flattened NumPy array. Of course, this is not usually the best way to compute the filter, as the matrices and vectors involved may be huge. For example, filtering a image with this method would require multiplication of a matrix with a vector. Just trying to store the matrix using a standard NumPy array would require elements. At 4 bytes per element this would require of memory. In most applications, most of the elements of this matrix are zero and a different method for computing the output of the filter is employed. Convolution/Correlation  Many linear filters also have the property of shift-invariance. This means that the filtering operation is the same at different locations in the signal and it implies that the filtering matrix can be constructed from knowledge of one row (or column) of the matrix alone. In this case, the matrix multiplication can be accomplished using Fourier transforms. Let define a 1-D signal indexed by the integer Full convolution of two 1-D signals can be expressed as \[y\left[n\right]\sum_{k-\infty}^{\infty}x\left[k\right]h\left[n-k\right].\] This equation can only be implemented directly if we limit the sequences to finite-support sequences that can be stored in a computer, choose to be the starting point of both sequences, let be that value for which for all and be that value for which for all , then the discrete convolution expression is \[y\left[n\right]\sum_{k\max\left(n-M,0\right)}^{\min\left(n,K\right)}x\left[k\right]h\left[n-k\right].\] For convenience, assume Then, more explicitly, the output of this operation is \begin{eqnarray*} y\left[0\right] &  & x\left[0\right]h\left[0\right]\\ y\left[1\right] &  & x\left[0\right]h\left[1\right]+x\left[1\right]h\left[0\right]\\ y\left[2\right] &  & x\left[0\right]h\left[2\right]+x\left[1\right]h\left[1\right]+x\left[2\right]h\left[0\right]\\ \vdots & \vdots & \vdots\\ y\left[M\right] &  & x\left[0\right]h\left[M\right]+x\left[1\right]h\left[M-1\right]+\cdots+x\left[M\right]h\left[0\right]\\ y\left[M+1\right] &  & x\left[1\right]h\left[M\right]+x\left[2\right]h\left[M-1\right]+\cdots+x\left[M+1\right]h\left[0\right]\\ \vdots & \vdots & \vdots\\ y\left[K\right] &  & x\left[K-M\right]h\left[M\right]+\cdots+x\left[K\right]h\left[0\right]\\ y\left[K+1\right] &  & x\left[K+1-M\right]h\left[M\right]+\cdots+x\left[K\right]h\left[1\right]\\ \vdots & \vdots & \vdots\\ y\left[K+M-1\right] &  & x\left[K-1\right]h\left[M\right]+x\left[K\right]h\left[M-1\right]\\ y\left[K+M\right] &  & x\left[K\right]h\left[M\right].\end{eqnarray*} Thus, the full discrete convolution of two finite sequences of lengths and , respectively, results in a finite sequence of length 1-D convolution is implemented in SciPy with the function convolve . This function takes as inputs the signals , and two optional flags ‘mode’ and ‘method’, and returns the signal The first optional flag, ‘mode’, allows for the specification of which part of the output signal to return. The default value of ‘full’ returns the entire signal. If the flag has a value of ‘same’, then only the middle values are returned, starting at , so that the output has the same length as the first input. If the flag has a value of ‘valid’, then only the middle output values are returned, where depends on all of the values of the smallest input from to In other words, only the values to inclusive are returned. The second optional flag, ‘method’, determines how the convolution is computed, either through the Fourier transform approach with fftconvolve or through the direct method. By default, it selects the expected faster method. The Fourier transform method has order , while the direct method has order . Depending on the big O constant and the value of , one of these two methods may be faster. The default value, ‘auto’, performs a rough calculation and chooses the expected faster method, while the values ‘direct’ and ‘fft’ force computation with the other two methods. The code below shows a simple example for convolution of 2 sequences: This same function convolve can actually take N-D arrays as inputs and will return the N-D convolution of the two arrays, as is shown in the code example below. The same input flags are available for that case as well. Correlation is very similar to convolution except that the minus sign becomes a plus sign. Thus, \[w\left[n\right]\sum_{k-\infty}^{\infty}y\left[k\right]x\left[n+k\right],\] is the (cross) correlation of the signals and For finite-length signals with outside of the range and outside of the range the summation can simplify to \[w\left[n\right]\sum_{k\max\left(0,-n\right)}^{\min\left(K,M-n\right)}y\left[k\right]x\left[n+k\right].\] Assuming again that , this is \begin{eqnarray*} w\left[-K\right] &  & y\left[K\right]x\left[0\right]\\ w\left[-K+1\right] &  & y\left[K-1\right]x\left[0\right]+y\left[K\right]x\left[1\right]\\ \vdots & \vdots & \vdots\\ w\left[M-K\right] &  & y\left[K-M\right]x\left[0\right]+y\left[K-M+1\right]x\left[1\right]+\cdots+y\left[K\right]x\left[M\right]\\ w\left[M-K+1\right] &  & y\left[K-M-1\right]x\left[0\right]+\cdots+y\left[K-1\right]x\left[M\right]\\ \vdots & \vdots & \vdots\\ w\left[-1\right] &  & y\left[1\right]x\left[0\right]+y\left[2\right]x\left[1\right]+\cdots+y\left[M+1\right]x\left[M\right]\\ w\left[0\right] &  & y\left[0\right]x\left[0\right]+y\left[1\right]x\left[1\right]+\cdots+y\left[M\right]x\left[M\right]\\ w\left[1\right] &  & y\left[0\right]x\left[1\right]+y\left[1\right]x\left[2\right]+\cdots+y\left[M-1\right]x\left[M\right]\\ w\left[2\right] &  & y\left[0\right]x\left[2\right]+y\left[1\right]x\left[3\right]+\cdots+y\left[M-2\right]x\left[M\right]\\ \vdots & \vdots & \vdots\\ w\left[M-1\right] &  & y\left[0\right]x\left[M-1\right]+y\left[1\right]x\left[M\right]\\ w\left[M\right] &  & y\left[0\right]x\left[M\right].\end{eqnarray*} The SciPy function correlate implements this operation. Equivalent flags are available for this operation to return the full length sequence (‘full’) or a sequence with the same size as the largest sequence starting at (‘same’) or a sequence where the values depend on all the values of the smallest sequence (‘valid’). This final option returns the values to inclusive. The function correlate can also take arbitrary N-D arrays as input and return the N-D convolution of the two arrays on output. When correlate and/or convolve can be used to construct arbitrary image filters to perform actions such as blurring, enhancing, and edge-detection for an image. Calculating the convolution in the time domain as above is mainly used for filtering when one of the signals is much smaller than the other ( ), otherwise linear filtering is more efficiently calculated in the frequency domain provided by the function fftconvolve . By default, convolve estimates the fastest method using choose_conv_method . If the filter function can be factored according to \[h[n, m]  h_1[n] h_2[m],\] convolution can be calculated by means of the function sepfir2d . As an example, we consider a Gaussian filter gaussian \[h[n, m] \propto e^{-x^2-y^2}  e^{-x^2} e^{-y^2},\] which is often used for blurring. Difference-equation filtering  A general class of linear 1-D filters (that includes convolution filters) are filters described by the difference equation \[\sum_{k0}^{N}a_{k}y\left[n-k\right]\sum_{k0}^{M}b_{k}x\left[n-k\right],\] where is the input sequence and is the output sequence. If we assume initial rest so that for , then this kind of filter can be implemented using convolution. However, the convolution filter sequence could be infinite if for In addition, this general class of linear filter allows initial conditions to be placed on for resulting in a filter that cannot be expressed using convolution. The difference equation filter can be thought of as finding recursively in terms of its previous values \[a_{0}y\left[n\right]-a_{1}y\left[n-1\right]-\cdots-a_{N}y\left[n-N\right]+\cdots+b_{0}x\left[n\right]+\cdots+b_{M}x\left[n-M\right].\] Often, is chosen for normalization. The implementation in SciPy of this general difference equation filter is a little more complicated than would be implied by the previous equation. It is implemented so that only one signal needs to be delayed. The actual implementation equations are (assuming ): \begin{eqnarray*} y\left[n\right] &  & b_{0}x\left[n\right]+z_{0}\left[n-1\right]\\ z_{0}\left[n\right] &  & b_{1}x\left[n\right]+z_{1}\left[n-1\right]-a_{1}y\left[n\right]\\ z_{1}\left[n\right] &  & b_{2}x\left[n\right]+z_{2}\left[n-1\right]-a_{2}y\left[n\right]\\ \vdots & \vdots & \vdots\\ z_{K-2}\left[n\right] &  & b_{K-1}x\left[n\right]+z_{K-1}\left[n-1\right]-a_{K-1}y\left[n\right]\\ z_{K-1}\left[n\right] &  & b_{K}x\left[n\right]-a_{K}y\left[n\right],\end{eqnarray*} where Note that if and if In this way, the output at time depends only on the input at time and the value of at the previous time. This can always be calculated as long as the values are computed and stored at each time step. The difference-equation filter is called using the command lfilter in SciPy. This command takes as inputs the vector the vector, a signal and returns the vector (the same length as ) computed using the equation given above. If is N-D, then the filter is computed along the axis provided. If desired, initial conditions providing the values of to can be provided or else it will be assumed that they are all zero. If initial conditions are provided, then the final conditions on the intermediate variables are also returned. These could be used, for example, to restart the calculation in the same state. Sometimes, it is more convenient to express the initial conditions in terms of the signals and In other words, perhaps you have the values of to and the values of to and would like to determine what values of should be delivered as initial conditions to the difference-equation filter. It is not difficult to show that, for \[z_{m}\left[n\right]\sum_{p0}^{K-m-1}\left(b_{m+p+1}x\left[n-p\right]-a_{m+p+1}y\left[n-p\right]\right).\] Using this formula, we can find the initial-condition vector to given initial conditions on (and ). The command lfiltic performs this function. As an example, consider the following system: \[y[n]  \frac{1}{2} x[n] + \frac{1}{4} x[n-1] + \frac{1}{3} y[n-1]\] The code calculates the signal for a given signal ; first for initial conditions (default case), then for by means of lfiltic . Note that the output signal has the same length as the length as the input signal . Analysis of Linear Systems  Linear system described a linear-difference equation can be fully described by the coefficient vectors and as was done above; an alternative representation is to provide a factor , zeros and poles , respectively, to describe the system by means of its transfer function , according to \[H(z)  k \frac{ (z-z_1)(z-z_2)...(z-z_{N_z})}{ (z-p_1)(z-p_2)...(z-p_{N_p})}.\] This alternative representation can be obtained with the scipy function tf2zpk ; the inverse is provided by zpk2tf . For the above example we have i.e., the system has a zero at and a pole at . The scipy function freqz allows calculation of the frequency response of a system described by the coefficients and . See the help of the freqz function for a comprehensive example. Filter Design  Time-discrete filters can be classified into finite response (FIR) filters and infinite response (IIR) filters. FIR filters can provide a linear phase response, whereas IIR filters cannot. SciPy provides functions for designing both types of filters. FIR Filter  The function firwin designs filters according to the window method. Depending on the provided arguments, the function returns different filter types (e.g., low-pass, band-pass…). The example below designs a low-pass and a band-stop filter, respectively. Note that firwin uses, per default, a normalized frequency defined such that the value corresponds to the Nyquist frequency, whereas the function freqz is defined such that the value corresponds to the Nyquist frequency. The function firwin2 allows design of almost arbitrary frequency responses by specifying an array of corner frequencies and corresponding gains, respectively. The example below designs a filter with such an arbitrary amplitude response. Note the linear scaling of the y-axis and the different definition of the Nyquist frequency in firwin2 and freqz (as explained above). IIR Filter  SciPy provides two functions to directly design IIR iirdesign and iirfilter , where the filter type (e.g., elliptic) is passed as an argument and several more filter design functions for specific filter types, e.g., ellip . The example below designs an elliptic low-pass filter with defined pass-band and stop-band ripple, respectively. Note the much lower filter order (order 4) compared with the FIR filters from the examples above in order to reach the same stop-band attenuation of dB. Filter Coefficients  Filter coefficients can be stored in several different formats: ‘ba’ or ‘tf’  transfer function coefficients ‘zpk’  zeros, poles, and overall gain ‘ss’  state-space system representation ‘sos’  transfer function coefficients of second-order sections Functions, such as tf2zpk and zpk2ss , can convert between them. Transfer function representation  The or format is a 2-tuple representing a transfer function, where b is a length array of coefficients of the M -order numerator polynomial, and a is a length array of coefficients of the N -order denominator, as positive, descending powers of the transfer function variable. So the tuple of and can represent an analog filter of the form: \[H(s)  \frac {b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M} {a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N}  \frac {\sum_{i0}^M b_i s^{(M-i)}} {\sum_{i0}^N a_i s^{(N-i)}}\] or a discrete-time filter of the form: \[H(z)  \frac {b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M} {a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N}  \frac {\sum_{i0}^M b_i z^{(M-i)}} {\sum_{i0}^N a_i z^{(N-i)}}.\] This “positive powers” form is found more commonly in controls engineering. If M and N are equal (which is true for all filters generated by the bilinear transform), then this happens to be equivalent to the “negative powers” discrete-time form preferred in DSP: \[H(z)  \frac {b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}} {a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}}  \frac {\sum_{i0}^M b_i z^{-i}} {\sum_{i0}^N a_i z^{-i}}.\] Although this is true for common filters, remember that this is not true in the general case. If M and N are not equal, the discrete-time transfer function coefficients must first be converted to the “positive powers” form before finding the poles and zeros. This representation suffers from numerical error at higher orders, so other formats are preferred when possible. Zeros and poles representation  The format is a 3-tuple , where z is an M -length array of the complex zeros of the transfer function , p is an N -length array of the complex poles of the transfer function , and k is a scalar gain. These represent the digital transfer function: \[H(z)  k \cdot \frac {(z - z_0) (z - z_1) \cdots (z - z_{(M-1)})} {(z - p_0) (z - p_1) \cdots (z - p_{(N-1)})}  k \frac {\prod_{i0}^{M-1} (z - z_i)} {\prod_{i0}^{N-1} (z - p_i)}\] or the analog transfer function: \[H(s)  k \cdot \frac {(s - z_0) (s - z_1) \cdots (s - z_{(M-1)})} {(s - p_0) (s - p_1) \cdots (s - p_{(N-1)})}  k \frac {\prod_{i0}^{M-1} (s - z_i)} {\prod_{i0}^{N-1} (s - p_i)}.\] Although the sets of roots are stored as ordered NumPy arrays, their ordering does not matter: is the same filter as . State-space system representation  The format is a 4-tuple of arrays representing the state-space of an N -order digital/discrete-time system of the form: \[\begin{split}\mathbf{x}[k+1]  A \mathbf{x}[k] + B \mathbf{u}[k]\\ \mathbf{y}[k]  C \mathbf{x}[k] + D \mathbf{u}[k]\end{split}\] or a continuous/analog system of the form: \[\begin{split}\dot{\mathbf{x}}(t)  A \mathbf{x}(t) + B \mathbf{u}(t)\\ \mathbf{y}(t)  C \mathbf{x}(t) + D \mathbf{u}(t),\end{split}\] with P inputs, Q outputs and N state variables, where: x is the state vector y is the output vector of length Q u is the input vector of length P A is the state matrix, with shape B is the input matrix with shape C is the output matrix with shape D is the feedthrough or feedforward matrix with shape . (In cases where the system does not have a direct feedthrough, all values in D are zero.) State-space is the most general representation and the only one that allows for multiple-input, multiple-output (MIMO) systems. There are multiple state-space representations for a given transfer function. Specifically, the “controllable canonical form” and “observable canonical form” have the same coefficients as the representation, and, therefore, suffer from the same numerical errors. Second-order sections representation  The format is a single 2-D array of shape , representing a sequence of second-order transfer functions which, when cascaded in series, realize a higher-order filter with minimal numerical error. Each row corresponds to a second-order representation, with the first three columns providing the numerator coefficients and the last three providing the denominator coefficients: \[[b_0, b_1, b_2, a_0, a_1, a_2]\] The coefficients are typically normalized, such that is always 1. The section order is usually not important with floating-point computation; the filter output will be the same, regardless of the order. Filter transformations  The IIR filter design functions first generate a prototype analog low-pass filter with a normalized cutoff frequency of 1 rad/sec. This is then transformed into other frequencies and band types using the following substitutions: Type Transformation lp2lp lp2hp lp2bp lp2bs Here, is the new cutoff or center frequency, and is the bandwidth. These preserve symmetry on a logarithmic frequency axis. To convert the transformed analog filter into a digital filter, the bilinear transform is used, which makes the following substitution: \[s \rightarrow \frac{2}{T} \frac{z - 1}{z + 1},\] where T is the sampling time (the inverse of the sampling frequency). Other filters  The signal processing package provides many more filters as well. Median Filter  A median filter is commonly applied when noise is markedly non-Gaussian or when it is desired to preserve edges. The median filter works by sorting all of the array pixel values in a rectangular region surrounding the point of interest. The sample median of this list of neighborhood pixel values is used as the value for the output array. The sample median is the middle-array value in a sorted list of neighborhood values. If there are an even number of elements in the neighborhood, then the average of the middle two values is used as the median. A general purpose median filter that works on N-D arrays is medfilt . A specialized version that works only for 2-D arrays is available as medfilt2d . Order Filter  A median filter is a specific example of a more general class of filters called order filters. To compute the output at a particular pixel, all order filters use the array values in a region surrounding that pixel. These array values are sorted and then one of them is selected as the output value. For the median filter, the sample median of the list of array values is used as the output. A general-order filter allows the user to select which of the sorted values will be used as the output. So, for example, one could choose to pick the maximum in the list or the minimum. The order filter takes an additional argument besides the input array and the region mask that specifies which of the elements in the sorted list of neighbor array values should be used as the output. The command to perform an order filter is order_filter . Wiener filter  The Wiener filter is a simple deblurring filter for denoising images. This is not the Wiener filter commonly described in image-reconstruction problems but, instead, it is a simple, local-mean filter. Let be the input signal, then the output is \[\begin{split}y\left\{ \begin{array}{cc} \frac{\sigma^{2}}{\sigma_{x}^{2}}m_{x}+\left(1-\frac{\sigma^{2}}{\sigma_{x}^{2}}\right)x & \sigma_{x}^{2}\geq\sigma^{2},\\ m_{x} & \sigma_{x}^{2}<\sigma^{2},\end{array}\right.\end{split}\] where is the local estimate of the mean and is the local estimate of the variance. The window for these estimates is an optional input parameter (default is ). The parameter is a threshold noise parameter. If is not given, then it is estimated as the average of the local variances. Hilbert filter  The Hilbert transform constructs the complex-valued analytic signal from a real signal. For example, if , then would return (except near the edges) In the frequency domain, the hilbert transform performs \[YX\cdot H,\] where is for positive frequencies, for negative frequencies, and for zero-frequencies. Analog Filter Design  The functions iirdesign , iirfilter , and the filter design functions for specific filter types (e.g., ellip ) all have a flag analog , which allows the design of analog filters as well. The example below designs an analog (IIR) filter, obtains via tf2zpk the poles and zeros and plots them in the complex s-plane. The zeros at and can be clearly seen in the amplitude response. 