scipy_multidimensional_image_processing_scipy_ndimage
Multidimensional image processing (scipy.ndimage)
ndimage.html
 Segmentation and labeling  Segmentation is the process of separating objects of interest from the background. The most simple approach is, probably, intensity thresholding, which is easily done with numpy functions: The result is a binary image, in which the individual objects still need to be identified and labeled. The function label generates an array where each object is assigned a unique number: The label function generates an array where the objects in the input are labeled with an integer index. It returns a tuple consisting of the array of object labels and the number of objects found, unless the output parameter is given, in which case only the number of objects is returned. The connectivity of the objects is defined by a structuring element. For instance, in 2D using a 4-connected structuring element gives: These two objects are not connected because there is no way in which we can place the structuring element, such that it overlaps with both objects. However, an 8-connected structuring element results in only a single object: If no structuring element is provided, one is generated by calling generate_binary_structure (see Binary morphology ) using a connectivity of one (which in 2D is the 4-connected structure of the first example). The input can be of any type, any value not equal to zero is taken to be part of an object. This is useful if you need to ‘re-label’ an array of object indices, for instance, after removing unwanted objects. Just apply the label function again to the index array. For instance: Note The structuring element used by label is assumed to be symmetric. There is a large number of other approaches for segmentation, for instance, from an estimation of the borders of the objects that can be obtained by derivative filters. One such approach is watershed segmentation. The function watershed_ift generates an array where each object is assigned a unique label, from an array that localizes the object borders, generated, for instance, by a gradient magnitude filter. It uses an array containing initial markers for the objects: The watershed_ift function applies a watershed from markers algorithm, using an Iterative Forest Transform, as described in 4 . The inputs of this function are the array to which the transform is applied, and an array of markers that designate the objects by a unique label, where any non-zero value is a marker. For instance: Here, two markers were used to designate an object ( marker  2) and the background ( marker  1). The order in which these are processed is arbitrary: moving the marker for the background to the lower-right corner of the array yields a different result: The result is that the object ( marker  2) is smaller because the second marker was processed earlier. This may not be the desired effect if the first marker was supposed to designate a background object. Therefore, watershed_ift treats markers with a negative value explicitly as background markers and processes them after the normal markers. For instance, replacing the first marker by a negative marker gives a result similar to the first example: The connectivity of the objects is defined by a structuring element. If no structuring element is provided, one is generated by calling generate_binary_structure (see Binary morphology ) using a connectivity of one (which in 2D is a 4-connected structure.) For example, using an 8-connected structure with the last example yields a different object: Note The implementation of watershed_ift limits the data types of the input to and . 