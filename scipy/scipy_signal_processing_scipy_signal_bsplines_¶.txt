scipy_signal_processing_scipy_signal
Signal Processing (scipy.signal)
signal.html
 B-splines  A B-spline is an approximation of a continuous function over a finite- domain in terms of B-spline coefficients and knot points. If the knot- points are equally spaced with spacing , then the B-spline approximation to a 1-D function is the finite-basis expansion. \[y\left(x\right)\approx\sum_{j}c_{j}\beta^{o}\left(\frac{x}{\Delta x}-j\right).\] In two dimensions with knot-spacing and , the function representation is \[z\left(x,y\right)\approx\sum_{j}\sum_{k}c_{jk}\beta^{o}\left(\frac{x}{\Delta x}-j\right)\beta^{o}\left(\frac{y}{\Delta y}-k\right).\] In these expressions, is the space-limited B-spline basis function of order . The requirement of equally-spaced knot-points and equally-spaced data points, allows the development of fast (inverse-filtering) algorithms for determining the coefficients, , from sample-values, . Unlike the general spline interpolation algorithms, these algorithms can quickly find the spline coefficients for large images. The advantage of representing a set of samples via B-spline basis functions is that continuous-domain operators (derivatives, re- sampling, integral, etc.), which assume that the data samples are drawn from an underlying continuous function, can be computed with relative ease from the spline coefficients. For example, the second derivative of a spline is \[y{}^{\prime\prime}\left(x\right)\frac{1}{\Delta x^{2}}\sum_{j}c_{j}\beta^{o\prime\prime}\left(\frac{x}{\Delta x}-j\right).\] Using the property of B-splines that \[\frac{d^{2}\beta^{o}\left(w\right)}{dw^{2}}\beta^{o-2}\left(w+1\right)-2\beta^{o-2}\left(w\right)+\beta^{o-2}\left(w-1\right),\] it can be seen that \[y^{\prime\prime}\left(x\right)\frac{1}{\Delta x^{2}}\sum_{j}c_{j}\left[\beta^{o-2}\left(\frac{x}{\Delta x}-j+1\right)-2\beta^{o-2}\left(\frac{x}{\Delta x}-j\right)+\beta^{o-2}\left(\frac{x}{\Delta x}-j-1\right)\right].\] If , then at the sample points: \begin{eqnarray*} \Delta x^{2}\left.y^{\prime}\left(x\right)\right|_{xn\Delta x} &  & \sum_{j}c_{j}\delta_{n-j+1}-2c_{j}\delta_{n-j}+c_{j}\delta_{n-j-1},\\ &  & c_{n+1}-2c_{n}+c_{n-1}.\end{eqnarray*} Thus, the second-derivative signal can be easily calculated from the spline fit. If desired, smoothing splines can be found to make the second derivative less sensitive to random errors. The savvy reader will have already noticed that the data samples are related to the knot coefficients via a convolution operator, so that simple convolution with the sampled B-spline function recovers the original data from the spline coefficients. The output of convolutions can change depending on how the boundaries are handled (this becomes increasingly more important as the number of dimensions in the dataset increases). The algorithms relating to B-splines in the signal-processing subpackage assume mirror-symmetric boundary conditions. Thus, spline coefficients are computed based on that assumption, and data-samples can be recovered exactly from the spline coefficients by assuming them to be mirror-symmetric also. Currently the package provides functions for determining second- and third- order cubic spline coefficients from equally-spaced samples in one and two dimensions ( qspline1d , qspline2d , cspline1d , cspline2d ). The package also supplies a function ( bspline ) for evaluating the B-spline basis function, for arbitrary order and For large , the B-spline basis function can be approximated well by a zero-mean Gaussian function with standard-deviation equal to : \[\beta^{o}\left(x\right)\approx\frac{1}{\sqrt{2\pi\sigma_{o}^{2}}}\exp\left(-\frac{x^{2}}{2\sigma_{o}}\right).\] A function to compute this Gaussian for arbitrary and is also available ( gauss_spline ). The following code and figure use spline-filtering to compute an edge-image (the second derivative of a smoothed spline) of a raccoonâ€™s face, which is an array returned by the command scipy.misc.face . The command sepfir2d was used to apply a separable 2-D FIR filter with mirror-symmetric boundary conditions to the spline coefficients. This function is ideally-suited for reconstructing samples from spline coefficients and is faster than convolve2d , which convolves arbitrary 2-D filters and allows for choosing mirror-symmetric boundary conditions. Alternatively, we could have done: 