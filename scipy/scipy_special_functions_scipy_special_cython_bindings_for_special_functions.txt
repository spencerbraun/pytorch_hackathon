scipy_special_functions_scipy_special
Special functions (scipy.special)
special.html
 Cython Bindings for Special Functions ( scipy.special.cython_special )  SciPy also offers Cython bindings for scalar, typed versions of many of the functions in special. The following Cython code gives a simple example of how to use these functions: (See the Cython documentation for help with compiling Cython.) In the example the function works essentially like its ufunc counterpart gamma , though it takes C types as arguments instead of NumPy arrays. Note, in particular, that the function is overloaded to support real and complex arguments; the correct variant is selected at compile time. The function works slightly differently from sici ; for the ufunc we could write , whereas in the Cython version multiple return values are passed as pointers. It might help to think of this as analogous to calling a ufunc with an output array: . There are two potential advantages to using the Cython bindings: they avoid Python function overhead they do not require the Python Global Interpreter Lock (GIL) The following sections discuss how to use these advantages to potentially speed up your code, though, of course, one should always profile the code first to make sure putting in the extra effort will be worth it. Avoiding Python Function Overhead  For the ufuncs in special, Python function overhead is avoided by vectorizing, that is, by passing an array to the function. Typically, this approach works quite well, but sometimes it is more convenient to call a special function on scalar inputs inside a loop, for example, when implementing your own ufunc. In this case, the Python function overhead can become significant. Consider the following example: On one computer took about 131 microseconds to run and took about 18.2 microseconds to run. Obviously this example is contrived: one could just call and get results just as fast as in . The point is that if Python function overhead becomes significant in your code, then the Cython bindings might be useful. Releasing the GIL  One often needs to evaluate a special function at many points, and typically the evaluations are trivially parallelizable. Since the Cython bindings do not require the GIL, it is easy to run them in parallel using Cythonâ€™s function. For example, suppose that we wanted to compute the fundamental solution to the Helmholtz equation: \[\Delta_x G(x, y) + k^2G(x, y)  \delta(x - y),\] where is the wavenumber and is the Dirac delta function. It is known that in two dimensions the unique (radiating) solution is \[G(x, y)  \frac{i}{4}H_0^{(1)}(k|x - y|),\] where is the Hankel function of the first kind, i.e., the function hankel1 . The following example shows how we could compute this function in parallel: (For help with compiling parallel code in Cython see here .) If the above Cython code is in a file , then we can write an informal benchmark which compares the parallel and serial versions of the function: On one quad-core computer the serial method took 1.29 seconds and the parallel method took 0.29 seconds. 