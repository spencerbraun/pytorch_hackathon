caret_13_using_your_own_model_in_train
13 Using Your Own Model in train
using-your-own-model-in-train.html
 13.3 Model Components You can pass a list of information to the method argument in train . For models that are built-in to the package, you can just pass the method name as before. There are some basic components of the list for custom models. A brief description is below for each then, after setting up and example, each will be described in detail. The list should have the following elements: library is a character vector of package names that will be needed to fit the model or calculate predictions. NULL can also be used. type is a simple character vector with values "Classification" , "Regression" or both. parameters is a data frame with three simple attributes for each tuning parameter (if any): the argument name (e.g. mtry ), the type of data in the parameter grid and textual labels for the parameter. grid is a function that is used to create the tuning grid (unless the user gives the exact values of the parameters via tuneGrid ) fit is a function that fits the model predict is the function that creates predictions prob is a function that can be used to create class probabilities (if applicable) sort is a function that sorts the parameter from most complex to least loop is an optional function for advanced users for models that can create multiple submodel predictions from the same object. levels is an optional function, primarily for classification models using S4 methods to return the factor levels of the outcome. tags is an optional character vector that has subjects associated with the model, such as Tree-Based Model or Embedded Feature Selection . This string is used by the package to create additional documentation pages on the package website. label is an optional character string that names the model (e.g. “Linear Discriminant Analysis”). predictors is an optional function that returns a character vector that contains the names of the predictors that we used in the prediction equation. varImp is an optional function that calculates variable importance metrics for the model (if any). oob is another optional function that calculates out-of-bag performance estimates from the model object. Most models do not have this capability but some (e.g. random forests, bagged models) do. notes is an optional character vector that can be used to document non-obvious aspects of the model. For example, there are two Bayesian lasso models ( blasso and blassoAveraged ) and this field is used to describe the differences between the two models. check is an optional function that can be used to check the system/install to make sure that any atypical software requirements are available to the user. The input is pkg , which is the same character string given by the library . This function is run after the checking function to see if the packages specified in library are installed. As an example, the model pythonKnnReg uses certain python libraries and the user should have python and these libraries installed. The model file demonstrates how to check for python libraries prior to running the R model. In the caret package, the subdirectory models has all the code for each model that train interfaces with and these can be used as prototypes for your model. Let’s create a new model for a classification support vector machin using the Laplacian kernel function. We will use the kernlab package’s ksvm function. The kernel has two parameters: the standard cost parameter for SVMs and one kernel parameter ( sigma ). To start, we’ll create a new list: This model can also be used for regression but we will constrain things here for simplicity. For other SVM models, the type value would be c("Classification", "Regression") . The library value checks to see if this package is installed and loads it whenever it is needed (e.g. before modeling or prediction). Note : caret will check to see if these packages are installed but will not explicitly load them. As such, functions that are used from the package should be referenced by namespace. This is discussed more below when describing the fit function. 13.3.1 The parameters Element We have to create some basic information for the parameters in the form of a data frame. The first column is the name of the parameter. The convention is to use the argument name in the model function (e.g. the ksvm function here). Those values are C and sigma . Each is a number and we can give them labels of "Cost" and "Sigma" , respectively. The parameters element would then be: Now we assign it to the model list: Values of type can indicate numeric, character or logical data types. 13.3.2 The grid Element This should be a function that takes parameters: x and y (for the predictors and outcome data), len (the number of values per tuning parameter) as well as search . len is the value of tuneLength that is potentially passed in through train . search can be either "grid" or "random" . This can be used to setup a grid for searching or random values for random search. The output should be a data frame of tuning parameter combinations with a column for each parameter. The column names should be the parameter name (e.g. the values of prm$parameter ). In our case, let’s vary the cost parameter on the log 2 scale. For the sigma parameter, we can use the kernlab function sigest to pre-estimate the value. Following ksvm we take the average of the low and high estimates. Here is a function we could use: Why did we use kernlab::sigest instead of sigest ? As previously mentioned, caret will not execute library(kernlab) unless you explicitly code it in these functions. Since it is not explicitly loaded, you have to call it using the namespace operator :: . Again, the user can pass their own grid via train ’s tuneGrid option or they can use this code to create a default grid. We assign this function to the overall model list: 13.3.3 The fit Element Here is where we fit the model. This fit function has several arguments: x , y : the current data used to fit the model wts : optional instance weights (not applicable for this particular model) param : the current tuning parameter values lev : the class levels of the outcome (or NULL in regression) last : a logical for whether the current fit is the final fit weights classProbs : a logical for whether class probabilities should be computed. Here is something we could use for this model: A few notes about this: Notice that the package is not loaded in the code. It is loaded prior to this function being called so it won’t hurt if you load it again (but that’s not needed). The ksvm function requires a matrix or predictors. If the original data were a data frame, this would throw and error. The tuning parameters are references in the param data frame. There is always a single row in this data frame. The probability model is fit based on the value of classProbs . This value is determined by the value given in trainControl . The three dots allow the user to pass options in from train to, in this case, the ksvm function. For example, if the use wanted to set the cache size for the function, they could list cache  80 and this argument will be pass from train to ksvm . Any pre-processing that was requested in the call to train have been done. For example, if preProc  "center" was originally requested, the columns of x seen within this function are mean centered. Again, the namespace operator :: is used for rbfdot and ksvm to ensure that the function can be found. 13.3.4 The predict Element This is a function that produces a vector or predictions. In our case these are class predictions but they could be numbers for regression models. The arguments are: modelFit : the model produced by the fit code shown above. newdata : the predictor values of the instances being predicted (e.g. out-of-bag samples) preProc submodels : this an optional list of tuning parameters only used with the loop element discussed below. In most cases, it will be NULL . Our function will be very simple: The function predict.ksvm will automatically create a factor vector as output. The function could also produce character values. Either way, the innards of train will make them factors and ensure that the same levels as the original data are used. 13.3.5 The prob Element If a regression model is being used or if the classification model does not create class probabilities a value of NULL can be used here instead of a function. Otherwise, the function arguments are the same as the pred function. The output should be a matrix or data frame of class probabilities with a column for each class. The column names should be the class levels. We can use: If you look at some of the SVM examples in the models directory, the real functions used by train are much more complicated so that they can deal with model failures, probabilities that do not sum to 1 etc. 