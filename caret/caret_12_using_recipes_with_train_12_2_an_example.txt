caret_12_using_recipes_with_train
12 Using Recipes with train
using-recipes-with-train.html
 12.2 An Example The QSARdata package contains several chemistry data sets. These data sets have rows for different potential drugs (called “compounds” here). For each compound, some important characteristic is measured. This illustration will use the AquaticTox data. The outcome is called “Activity” is a measure of how harmful the compound might be to people. We want to predict this during the drug discovery phase in R&D To do this, a set of molecular descriptors are computed based on the compounds formula. There are a lot of different types of these and we will use the 2-dimensional MOE descriptor set. First, lets’ load the package and get the data together: We will build a model on these data to predict the activity. Some notes: A common aspect to chemical descriptors is that they are highly correlated . Many descriptors often measure some variation of the same thing. For example, in these data, there are 56 potential predictors that measure different flavors of surface area. It might be a good idea to reduce the dimensionality of these data by pre-filtering the predictors and/or using a dimension reduction technique. Other descriptors are counts of certain types of aspects of the molecule. For example, one predictor is the number of Bromine atoms. The vast majority of compounds lack Bromine and this leads to a near-zero variance situation discussed previously. It might be a good idea to pre-filter these. Also, to demonstrate the utility of recipes, suppose that we could score potential drugs on the basis of how manufacturable they might be. We might want to build a model on the entire data set but only evaluate it on compounds that could be reasonably manufactured. For illustration, we’ll assume that, as a compounds molecule weight increases, its manufacturability decreases . For this purpose, we create a new variable ( manufacturability ) that is neither an outcome or predictor but will be needed to compute performance. For this analysis, we will compute the RMSE using weights based on the manufacturability column such that a difficult compound has less impact on the RMSE. There is no way to include this extra variable using the default train method or using train.formula . Now, let’s create a recipe incrementally. First, we will use the formula methods to declare the outcome and predictors but change the analysis role of the manufacturability variable so that it will only be available when summarizing the model fit. Using this new role, the manufacturability column will be available when the summary function is executed and the appropriate rows of the data set will be exposed during resampling. For example, if one were to debug the model_stats function during execution of a model, the data object might look like this: More than one variable can have this role so that multiple columns can be made available. Now let’s add some steps to the recipe First, we remove sparse and unbalanced predictors: Note that we have only specified what will happen once the recipe is executed. This is only a specification that uses a generic declaration of all_predictors . As mentioned above, there are a lot of different surface area predictors and they tend to have very high correlations with one another. We’ll add one or more predictors to the model in place of these predictors using principal component analysis. The step will retain the number of components required to capture 95% of the information contained in these 56 predictors. We’ll name these new predictors surf_area_1 , surf_area_2 etc. Now, lets specific that the third step in the recipe is to reduce the number of predictors so that no pair has an absolute correlation greater than 0.90. However, we might want to keep the surface area principal components so we exclude these from the filter (using the minus sign) Finally, we can center and scale all of the predictors that are available at the end of the recipe: Let’s use this recipe to fit a SVM model and pick the tuning parameters that minimize the weighted RMSE value: What variables were generated by the recipe? The trained recipe is available in the train object and now shows specific variables involved in each step: 