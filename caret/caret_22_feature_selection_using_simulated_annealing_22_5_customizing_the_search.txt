caret_22_feature_selection_using_simulated_annealing
22 Feature Selection using Simulated Annealing
feature-selection-using-simulated-annealing.html
 22.5 Customizing the Search 22.5.1 The fit Function This function builds the model based on a proposed current subset. The arguments for the function must be: x : the current training set of predictor data with the appropriate subset of variables y : the current outcome data (either a numeric or factor vector) lev : a character vector with the class levels (or NULL for regression problems) last : a logical that is TRUE when the final SA search is conducted on the entire data set ... : optional arguments to pass to the fit function in the call to safs The function should return a model object that can be used to generate predictions. For random forest, the fit function is simple: 22.5.2 The pred Function This function returns a vector of predictions (numeric or factors) from the current model. The input arguments must be object : the model generated by the fit function x : the current set of predictor set for the held-back samples For random forests, the function is a simple wrapper for the predict function: For classification, it is probably a good idea to ensure that the resulting factor variables of predictions has the same levels as the input data. 22.5.3 The fitness_intern Function The fitness_intern function takes the fitted model and computes one or more performance metrics. The inputs to this function are: object : the model generated by the fit function x : the current set of predictor set. If the option safsControl$holdout is zero, these values will be from the current resample (i.e.Â the same data used to fit the model). Otherwise, the predictor values are from the hold-out set created by safsControl$holdout . y : outcome values. See the note for the x argument to understand which data are presented to the function. maximize : a logical from safsControl that indicates whether the metric should be maximized or minimized p : the total number of possible predictors The output should be a named numeric vector of performance values. In many cases, some resampled measure of performance is used. In the example above using random forest, the OOB error was used. In other cases, the resampled performance from train can be used and, if safsControl$holdout is not zero, a static hold-out set can be used. This depends on the data and problem at hand. If left The example function for random forest is: 22.5.4 The fitness_extern Function The fitness_extern function takes the observed and predicted values form the external resampling process and computes one or more performance metrics. The input arguments are: data : a data frame or predictions generated by the fit function. For regression, the predicted values in a column called pred . For classification, pred is a factor vector. Class probabilities are usually attached as columns whose names are the class levels (see the random forest example for the fit function above) lev : a character vector with the class levels (or NULL for regression problems) The output should be a named numeric vector of performance values. The example function for random forest is: Two functions in caret that can be used as the summary function are defaultSummary and twoClassSummary (for classification problems with two classes). 22.5.5 The initial Function This function creates an initial subset. Inputs are: vars : the number of possible predictors prob : the probability that a feature is in the subset ... : not currently used The output should be a vector of integers indicating which predictors are in the initial subset. Alternatively, instead of a function, a vector of integers can be used in this slot. 22.5.6 The perturb Function This function perturbs the subset. Inputs are: x : the integers defining the current subset vars : the number of possible predictors number : the number of predictors to randomly change ... : not currently used The output should be a vector of integers indicating which predictors are in the new subset. 22.5.7 The prob Function This function computes the acceptance probability. Inputs are: old : the fitness value for the current subset new : the fitness value for the new subset iteration : the current iteration number or, if the improve argument of safsControl is used, the number of iterations since the last restart ... : not currently used The output should be a numeric value between zero and one. One of the biggest difficulties in using simulated annealing is the specification of the acceptance probability calculation. There are many references on different methods for doing this but the general consensus is that 1) the probability should decrease as the difference between the current and new solution increases and 2) the probability should decrease over iterations. One issue is that the difference in fitness values can be scale-dependent. In this package, the default probability calculations uses the percent difference, i.e. (current - new)/current to normalize the difference. The basic form of the probability simply takes the difference, multiplies by the iteration number and exponentiates this product: To demonstrate this, the plot below shows the probability profile for different fitness values of the current subset and different (absolute) differences. For the example data that were simulated, the RMSE values ranged between values greater than 4 to just under 3. In the plot below, the red curve in the right-hand panel shows how the probability changes over time when comparing a current value of 4 with a new values of 4.5 (smaller values being better). While this difference would likely be accepted in the first few iterations, it is unlikely to be accepted after 30 or 40. Also, larger differences are uniformly disfavored relative to smaller differences. While this is the default, any user-written function can be used to assign probabilities. 