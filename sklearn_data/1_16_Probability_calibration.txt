<div class="section" id="probability-calibration">
<span id="calibration"></span><h1>1.16. Probability calibration<a class="headerlink" href="#probability-calibration" title="Permalink to this headline">¶</a></h1>
<p>When performing classification you often want not only to predict the class
label, but also obtain a probability of the respective label. This probability
gives you some kind of confidence on the prediction. Some models can give you
poor estimates of the class probabilities and some even do not support
probability prediction. The calibration module allows you to better calibrate
the probabilities of a given model, or to add support for probability
prediction.</p>
<p>Well calibrated classifiers are probabilistic classifiers for which the output
of the predict_proba method can be directly interpreted as a confidence level.
For instance, a well calibrated (binary) classifier should classify the samples
such that among the samples to which it gave a predict_proba value close to 0.8,
approximately 80% actually belong to the positive class.</p>
<div class="section" id="calibration-curves">
<h2>1.16.1. Calibration curves<a class="headerlink" href="#calibration-curves" title="Permalink to this headline">¶</a></h2>
<p>The following plot compares how well the probabilistic predictions of
different classifiers are calibrated, using <a class="reference internal" href="generated/sklearn.calibration.calibration_curve.html#sklearn.calibration.calibration_curve" title="sklearn.calibration.calibration_curve"><code class="xref py py-func docutils literal notranslate"><span class="pre">calibration_curve</span></code></a>.
The x axis represents the average predicted probability in each bin. The
y axis is the <em>fraction of positives</em>, i.e. the proportion of samples whose
class is the positive class (in each bin).</p>
<div class="figure align-center">
<a class="reference external image-reference" href="../auto_examples/calibration/plot_compare_calibration.html"><img alt="../_images/sphx_glr_plot_compare_calibration_0011.png" src="../_images/sphx_glr_plot_compare_calibration_0011.png"/></a>
</div>
<p><a class="reference internal" href="generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression" title="sklearn.linear_model.LogisticRegression"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogisticRegression</span></code></a> returns well calibrated predictions by default as it directly
optimizes log-loss. In contrast, the other methods return biased probabilities;
with different biases per method:</p>
<p><a class="reference internal" href="generated/sklearn.naive_bayes.GaussianNB.html#sklearn.naive_bayes.GaussianNB" title="sklearn.naive_bayes.GaussianNB"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianNB</span></code></a> tends to push probabilities to 0 or 1 (note the counts
in the histograms). This is mainly because it makes the assumption that
features are conditionally independent given the class, which is not the
case in this dataset which contains 2 redundant features.</p>
<p><a class="reference internal" href="generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier" title="sklearn.ensemble.RandomForestClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code></a> shows the opposite behavior: the histograms
show peaks at approximately 0.2 and 0.9 probability, while probabilities
close to 0 or 1 are very rare. An explanation for this is given by
Niculescu-Mizil and Caruana <a class="footnote-reference brackets" href="#id6" id="id1">1</a>: “Methods such as bagging and random
forests that average predictions from a base set of models can have
difficulty making predictions near 0 and 1 because variance in the
underlying base models will bias predictions that should be near zero or one
away from these values. Because predictions are restricted to the interval
[0,1], errors caused by variance tend to be one-sided near zero and one. For
example, if a model should predict p = 0 for a case, the only way bagging
can achieve this is if all bagged trees predict zero. If we add noise to the
trees that bagging is averaging over, this noise will cause some trees to
predict values larger than 0 for this case, thus moving the average
prediction of the bagged ensemble away from 0. We observe this effect most
strongly with random forests because the base-level trees trained with
random forests have relatively high variance due to feature subsetting.” As
a result, the calibration curve also referred to as the reliability diagram
(Wilks 1995 <a class="footnote-reference brackets" href="#id7" id="id2">2</a>) shows a characteristic sigmoid shape, indicating that the
classifier could trust its “intuition” more and return probabilities closer
to 0 or 1 typically.</p>
<p>Linear Support Vector Classification (<a class="reference internal" href="generated/sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC" title="sklearn.svm.LinearSVC"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSVC</span></code></a>) shows an even more
sigmoid curve as the RandomForestClassifier, which is typical for
maximum-margin methods (compare Niculescu-Mizil and Caruana <a class="footnote-reference brackets" href="#id6" id="id3">1</a>), which
focus on hard samples that are close to the decision boundary (the support
vectors).</p>
</div>
<div class="section" id="calibrating-a-classifier">
<h2>1.16.2. Calibrating a classifier<a class="headerlink" href="#calibrating-a-classifier" title="Permalink to this headline">¶</a></h2>
<p>Calibrating a classifier consists in fitting a regressor (called a
<em>calibrator</em>) that maps the output of the classifier (as given by
<a class="reference internal" href="../glossary.html#term-predict"><span class="xref std std-term">predict</span></a> or <a class="reference internal" href="../glossary.html#term-predict-proba"><span class="xref std std-term">predict_proba</span></a>) to a calibrated probability in [0,
1]. Denoting the output of the classifier for a given sample by <span class="math notranslate nohighlight">\(f_i\)</span>,
the calibrator tries to predict <span class="math notranslate nohighlight">\(p(y_i = 1 | f_i)\)</span>.</p>
<p>The samples that are used to train the calibrator should not be used to
train the target classifier.</p>
</div>
<div class="section" id="usage">
<h2>1.16.3. Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV" title="sklearn.calibration.CalibratedClassifierCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibratedClassifierCV</span></code></a> class is used to calibrate a classifier.</p>
<p><a class="reference internal" href="generated/sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV" title="sklearn.calibration.CalibratedClassifierCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibratedClassifierCV</span></code></a> uses a cross-validation approach to fit both
the classifier and the regressor. For each of the k <code class="docutils literal notranslate"><span class="pre">(trainset,</span> <span class="pre">testset)</span></code>
couple, a classifier is trained on the train set, and its predictions on the
test set are used to fit a regressor. We end up with k
<code class="docutils literal notranslate"><span class="pre">(classifier,</span> <span class="pre">regressor)</span></code> couples where each regressor maps the output of
its corresponding classifier into [0, 1]. Each couple is exposed in the
<code class="docutils literal notranslate"><span class="pre">calibrated_classifiers_</span></code> attribute, where each entry is a calibrated
classifier with a <a class="reference internal" href="../glossary.html#term-predict-proba"><span class="xref std std-term">predict_proba</span></a> method that outputs calibrated
probabilities. The output of <a class="reference internal" href="../glossary.html#term-predict-proba"><span class="xref std std-term">predict_proba</span></a> for the main
<a class="reference internal" href="generated/sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV" title="sklearn.calibration.CalibratedClassifierCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibratedClassifierCV</span></code></a> instance corresponds to the average of the
predicted probabilities of the <code class="docutils literal notranslate"><span class="pre">k</span></code> estimators in the
<code class="docutils literal notranslate"><span class="pre">calibrated_classifiers_</span></code> list. The output of <a class="reference internal" href="../glossary.html#term-predict"><span class="xref std std-term">predict</span></a> is the class
that has the highest probability.</p>
<p>The regressor that is used for calibration depends on the <code class="docutils literal notranslate"><span class="pre">method</span></code>
parameter. <code class="docutils literal notranslate"><span class="pre">'sigmoid'</span></code> corresponds to a parametric approach based on Platt’s
logistic model <a class="footnote-reference brackets" href="#id8" id="id4">3</a>, i.e. <span class="math notranslate nohighlight">\(p(y_i = 1 | f_i)\)</span> is modeled as
<span class="math notranslate nohighlight">\(\sigma(A f_i + B)\)</span> where <span class="math notranslate nohighlight">\(\sigma\)</span> is the logistic function, and
<span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are real numbers to be determined when fitting the
regressor via maximum likelihood. <code class="docutils literal notranslate"><span class="pre">'isotonic'</span></code> will instead fit a
non-parametric isotonic regressor, which outputs a step-wise non-decreasing
function (see <a class="reference internal" href="classes.html#module-sklearn.isotonic" title="sklearn.isotonic"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.isotonic</span></code></a>).</p>
<p>An already fitted classifier can be calibrated by setting <code class="docutils literal notranslate"><span class="pre">cv="prefit"</span></code>. In
this case, the data is only used to fit the regressor. It is up to the user
make sure that the data used for fitting the classifier is disjoint from the
data used for fitting the regressor.</p>
<p><a class="reference internal" href="generated/sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV" title="sklearn.calibration.CalibratedClassifierCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibratedClassifierCV</span></code></a> can calibrate probabilities in a multiclass
setting if the base estimator supports multiclass predictions. The classifier
is calibrated first for each class separately in a one-vs-rest fashion <a class="footnote-reference brackets" href="#id9" id="id5">4</a>.
When predicting probabilities, the calibrated probabilities for each class
are predicted separately. As those probabilities do not necessarily sum to
one, a postprocessing is performed to normalize them.</p>
<p>The <a class="reference internal" href="generated/sklearn.metrics.brier_score_loss.html#sklearn.metrics.brier_score_loss" title="sklearn.metrics.brier_score_loss"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.metrics.brier_score_loss</span></code></a> may be used to evaluate how
well a classifier is calibrated.</p>
<div class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/calibration/plot_calibration_curve.html#sphx-glr-auto-examples-calibration-plot-calibration-curve-py"><span class="std std-ref">Probability Calibration curves</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/calibration/plot_calibration_multiclass.html#sphx-glr-auto-examples-calibration-plot-calibration-multiclass-py"><span class="std std-ref">Probability Calibration for 3-class classification</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/calibration/plot_calibration.html#sphx-glr-auto-examples-calibration-plot-calibration-py"><span class="std std-ref">Probability calibration of classifiers</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/calibration/plot_compare_calibration.html#sphx-glr-auto-examples-calibration-plot-compare-calibration-py"><span class="std std-ref">Comparison of Calibration of Classifiers</span></a></p></li>
</ul>
</div>
<div class="topic">
<p class="topic-title">References:</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>Predicting Good Probabilities with Supervised Learning,
A. Niculescu-Mizil &amp; R. Caruana, ICML 2005</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>On the combination of forecast probabilities for
consecutive precipitation periods. Wea. Forecasting, 5, 640–650.,
Wilks, D. S., 1990a</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Probabilistic Outputs for Support Vector Machines and Comparisons
to Regularized Likelihood Methods, J. Platt, (1999)</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>Transforming Classifier Scores into Accurate Multiclass
Probability Estimates, B. Zadrozny &amp; C. Elkan, (KDD 2002)</p>
</dd>
</dl>
</div>
</div>
</div>