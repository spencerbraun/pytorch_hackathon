sklearn_3_1_cross-validation_evaluating_estimator_performance
3.1. Cross-validation: evaluating estimator performance
modules/cross_validation.html
 3.1.2. Cross validation iterators  The following sections list utilities to generate indices that can be used to generate dataset splits according to different cross validation strategies. 3.1.2.1. Cross-validation iterators for i.i.d. data  Assuming that some data is Independent and Identically Distributed (i.i.d.) is making the assumption that all samples stem from the same generative process and that the generative process is assumed to have no memory of past generated samples. The following cross-validators can be used in such cases. NOTE While i.i.d. data is a common assumption in machine learning theory, it rarely holds in practice. If one knows that the samples have been generated using a time-dependent process, it is safer to use a time-series aware cross-validation scheme . Similarly, if we know that the generative process has a group structure (samples collected from different subjects, experiments, measurement devices), it is safer to use group-wise cross-validation . 3.1.2.1.1. K-fold  KFold divides all the samples in groups of samples, called folds (if , this is equivalent to the Leave One Out strategy), of equal sizes (if possible). The prediction function is learned using folds, and the fold left out is used for test. Example of 2-fold cross-validation on a dataset with 4 samples: Here is a visualization of the cross-validation behavior. Note that KFold is not affected by classes or groups. Each fold is constituted by two arrays: the first one is related to the training set , and the second one to the test set . Thus, one can create the training/test sets using numpy indexing: 3.1.2.1.2. Repeated K-Fold  RepeatedKFold repeats K-Fold n times. It can be used when one requires to run KFold n times, producing different splits in each repetition. Example of 2-fold K-Fold repeated 2 times: Similarly, RepeatedStratifiedKFold repeats Stratified K-Fold n times with different randomization in each repetition. 3.1.2.1.3. Leave One Out (LOO)  LeaveOneOut (or LOO) is a simple cross-validation. Each learning set is created by taking all the samples except one, the test set being the sample left out. Thus, for samples, we have different training sets and different tests set. This cross-validation procedure does not waste much data as only one sample is removed from the training set: Potential users of LOO for model selection should weigh a few known caveats. When compared with -fold cross validation, one builds models from samples instead of models, where . Moreover, each is trained on samples rather than . In both ways, assuming is not too large and , LOO is more computationally expensive than -fold cross validation. In terms of accuracy, LOO often results in high variance as an estimator for the test error. Intuitively, since of the samples are used to build each model, models constructed from folds are virtually identical to each other and to the model built from the entire training set. However, if the learning curve is steep for the training size in question, then 5- or 10- fold cross validation can overestimate the generalization error. As a general rule, most authors, and empirical evidence, suggest that 5- or 10- fold cross validation should be preferred to LOO. References: http://www.faqs.org/faqs/ai-faq/neural-nets/part3/section-12.html ; T. Hastie, R. Tibshirani, J. Friedman, The Elements of Statistical Learning , Springer 2009 L. Breiman, P. Spector Submodel selection and evaluation in regression: The X-random case , International Statistical Review 1992; R. Kohavi, A Study of Cross-Validation and Bootstrap for Accuracy Estimation and Model Selection , Intl. Jnt. Conf. AI R. Bharat Rao, G. Fung, R. Rosales, On the Dangers of Cross-Validation. An Experimental Evaluation , SIAM 2008; G. James, D. Witten, T. Hastie, R Tibshirani, An Introduction to Statistical Learning , Springer 2013. 3.1.2.1.4. Leave P Out (LPO)  LeavePOut is very similar to LeaveOneOut as it creates all the possible training/test sets by removing samples from the complete set. For samples, this produces train-test pairs. Unlike LeaveOneOut and KFold , the test sets will overlap for . Example of Leave-2-Out on a dataset with 4 samples: 3.1.2.1.5. Random permutations cross-validation a.k.a. Shuffle & Split  ShuffleSplit The ShuffleSplit iterator will generate a user defined number of independent train / test dataset splits. Samples are first shuffled and then split into a pair of train and test sets. It is possible to control the randomness for reproducibility of the results by explicitly seeding the pseudo random number generator. Here is a usage example: Here is a visualization of the cross-validation behavior. Note that ShuffleSplit is not affected by classes or groups. ShuffleSplit is thus a good alternative to KFold cross validation that allows a finer control on the number of iterations and the proportion of samples on each side of the train / test split. 3.1.2.2. Cross-validation iterators with stratification based on class labels.  Some classification problems can exhibit a large imbalance in the distribution of the target classes: for instance there could be several times more negative samples than positive samples. In such cases it is recommended to use stratified sampling as implemented in StratifiedKFold and StratifiedShuffleSplit to ensure that relative class frequencies is approximately preserved in each train and validation fold. 3.1.2.2.1. Stratified k-fold  StratifiedKFold is a variation of k-fold which returns stratified folds: each set contains approximately the same percentage of samples of each target class as the complete set. Here is an example of stratified 3-fold cross-validation on a dataset with 50 samples from two unbalanced classes. We show the number of samples in each class and compare with KFold . We can see that StratifiedKFold preserves the class ratios (approximately 1 / 10) in both train and test dataset. Here is a visualization of the cross-validation behavior. RepeatedStratifiedKFold can be used to repeat Stratified K-Fold n times with different randomization in each repetition. 3.1.2.2.2. Stratified Shuffle Split  StratifiedShuffleSplit is a variation of ShuffleSplit , which returns stratified splits, i.e which creates splits by preserving the same percentage for each target class as in the complete set. Here is a visualization of the cross-validation behavior. 3.1.2.3. Cross-validation iterators for grouped data.  The i.i.d. assumption is broken if the underlying generative process yield groups of dependent samples. Such a grouping of data is domain specific. An example would be when there is medical data collected from multiple patients, with multiple samples taken from each patient. And such data is likely to be dependent on the individual group. In our example, the patient id for each sample will be its group identifier. In this case we would like to know if a model trained on a particular set of groups generalizes well to the unseen groups. To measure this, we need to ensure that all the samples in the validation fold come from groups that are not represented at all in the paired training fold. The following cross-validation splitters can be used to do that. The grouping identifier for the samples is specified via the parameter. 3.1.2.3.1. Group k-fold  GroupKFold is a variation of k-fold which ensures that the same group is not represented in both testing and training sets. For example if the data is obtained from different subjects with several samples per-subject and if the model is flexible enough to learn from highly person specific features it could fail to generalize to new subjects. GroupKFold makes it possible to detect this kind of overfitting situations. Imagine you have three subjects, each with an associated number from 1 to 3: Each subject is in a different testing fold, and the same subject is never in both testing and training. Notice that the folds do not have exactly the same size due to the imbalance in the data. Here is a visualization of the cross-validation behavior. 3.1.2.3.2. Leave One Group Out  LeaveOneGroupOut is a cross-validation scheme which holds out the samples according to a third-party provided array of integer groups. This group information can be used to encode arbitrary domain specific pre-defined cross-validation folds. Each training set is thus constituted by all the samples except the ones related to a specific group. For example, in the cases of multiple experiments, LeaveOneGroupOut can be used to create a cross-validation based on the different experiments: we create a training set using the samples of all the experiments except one: Another common application is to use time information: for instance the groups could be the year of collection of the samples and thus allow for cross-validation against time-based splits. 3.1.2.3.3. Leave P Groups Out  LeavePGroupsOut is similar as LeaveOneGroupOut , but removes samples related to groups for each training/test set. Example of Leave-2-Group Out: 3.1.2.3.4. Group Shuffle Split  The GroupShuffleSplit iterator behaves as a combination of ShuffleSplit and LeavePGroupsOut , and generates a sequence of randomized partitions in which a subset of groups are held out for each split. Here is a usage example: Here is a visualization of the cross-validation behavior. This class is useful when the behavior of LeavePGroupsOut is desired, but the number of groups is large enough that generating all possible partitions with groups withheld would be prohibitively expensive. In such a scenario, GroupShuffleSplit provides a random sample (with replacement) of the train / test splits generated by LeavePGroupsOut . 3.1.2.4. Predefined Fold-Splits / Validation-Sets  For some datasets, a pre-defined split of the data into training- and validation fold or into several cross-validation folds already exists. Using PredefinedSplit it is possible to use these folds e.g. when searching for hyperparameters. For example, when using a validation set, set the to 0 for all samples that are part of the validation set, and to -1 for all other samples. 3.1.2.5. Cross validation of time series data  Time series data is characterised by the correlation between observations that are near in time ( autocorrelation ). However, classical cross-validation techniques such as KFold and ShuffleSplit assume the samples are independent and identically distributed, and would result in unreasonable correlation between training and testing instances (yielding poor estimates of generalisation error) on time series data. Therefore, it is very important to evaluate our model for time series data on the “future” observations least like those that are used to train the model. To achieve this, one solution is provided by TimeSeriesSplit . 3.1.2.5.1. Time Series Split  TimeSeriesSplit is a variation of k-fold which returns first folds as train set and the th fold as test set. Note that unlike standard cross-validation methods, successive training sets are supersets of those that come before them. Also, it adds all surplus data to the first training partition, which is always used to train the model. This class can be used to cross-validate time series data samples that are observed at fixed time intervals. Example of 3-split time series cross-validation on a dataset with 6 samples: Here is a visualization of the cross-validation behavior. 