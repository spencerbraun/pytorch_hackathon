scipy_sparse_eigenvalue_problems_with_arpack
Sparse eigenvalue problems with ARPACK
arpack.html
 Examples  Imagine you’d like to find the smallest and largest eigenvalues and the corresponding eigenvectors for a large matrix. ARPACK can handle many forms of input: dense matrices ,such as numpy.ndarray instances, sparse matrices, such as scipy.sparse.csr_matrix , or a general linear operator derived from scipy.sparse.linalg.LinearOperator . For this example, for simplicity, we’ll construct a symmetric, positive-definite matrix. We now have a symmetric matrix , with which to test the routines. First, compute a standard eigenvalue decomposition using : As the dimension of grows, this routine becomes very slow. Especially, if only a few eigenvectors and eigenvalues are needed, can be a better option. First let’s compute the largest eigenvalues ( ) of and compare them to the known results: The results are as expected. ARPACK recovers the desired eigenvalues and they match the previously known results. Furthermore, the eigenvectors are orthogonal, as we’d expect. Now, let’s attempt to solve for the eigenvalues with smallest magnitude: Oops. We see that, as mentioned above, is not quite as adept at finding small eigenvalues. There are a few ways this problem can be addressed. We could increase the tolerance ( ) to lead to faster convergence: This works, but we lose the precision in the results. Another option is to increase the maximum number of iterations ( ) from 1000 to 5000: We get the results we’d hoped for, but the computation time is much longer. Fortunately, contains a mode that allows a quick determination of non-external eigenvalues: shift-invert mode . As mentioned above, this mode involves transforming the eigenvalue problem to an equivalent problem with different eigenvalues. In this case, we hope to find eigenvalues near zero, so we’ll choose . The transformed eigenvalues will then satisfy , so our small eigenvalues become large eigenvalues . We get the results we were hoping for, with much less computational time. Note that the transformation from takes place entirely in the background. The user need not worry about the details. The shift-invert mode provides more than just a fast way to obtain a few small eigenvalues. Say, you desire to find internal eigenvalues and eigenvectors, e.g., those nearest to . Simply set and ARPACK will take care of the rest: The eigenvalues come out in a different order, but they’re all there. Note that the shift-invert mode requires the internal solution of a matrix inverse. This is taken care of automatically by and eigs , but the operation can also be specified by the user. See the docstring of scipy.sparse.linalg.eigsh and scipy.sparse.linalg.eigs for details. 