sklearn_2_5_decomposing_signals_in_components_matrix_factorization_problems
2.5. Decomposing signals in components (matrix factorization problems)
modules/decomposition.html
 2.5.1. Principal component analysis (PCA)  2.5.1.1. Exact PCA and probabilistic interpretation  PCA is used to decompose a multivariate dataset in a set of successive orthogonal components that explain a maximum amount of the variance. In scikit-learn, PCA is implemented as a transformer object that learns components in its method, and can be used on new data to project it on these components. PCA centers but does not scale the input data for each feature before applying the SVD. The optional parameter makes it possible to project the data onto the singular space while scaling each component to unit variance. This is often useful if the models down-stream make strong assumptions on the isotropy of the signal: this is for example the case for Support Vector Machines with the RBF kernel and the K-Means clustering algorithm. Below is an example of the iris dataset, which is comprised of 4 features, projected on the 2 dimensions that explain most variance: The PCA object also provides a probabilistic interpretation of the PCA that can give a likelihood of data based on the amount of variance it explains. As such it implements a score method that can be used in cross-validation: Examples: Comparison of LDA and PCA 2D projection of Iris dataset Model selection with Probabilistic PCA and Factor Analysis (FA) 2.5.1.2. Incremental PCA  The PCA object is very useful, but has certain limitations for large datasets. The biggest limitation is that PCA only supports batch processing, which means all of the data to be processed must fit in main memory. The IncrementalPCA object uses a different form of processing and allows for partial computations which almost exactly match the results of PCA while processing the data in a minibatch fashion. IncrementalPCA makes it possible to implement out-of-core Principal Component Analysis either by: Using its method on chunks of data fetched sequentially from the local hard drive or a network database. Calling its fit method on a sparse matrix or a memory mapped file using . IncrementalPCA only stores estimates of component and noise variances, in order update incrementally. This is why memory usage depends on the number of samples per batch, rather than the number of samples to be processed in the dataset. As in PCA , IncrementalPCA centers but does not scale the input data for each feature before applying the SVD. Examples: Incremental PCA 2.5.1.3. PCA using randomized SVD  It is often interesting to project data to a lower-dimensional space that preserves most of the variance, by dropping the singular vector of components associated with lower singular values. For instance, if we work with 64x64 pixel gray-level pictures for face recognition, the dimensionality of the data is 4096 and it is slow to train an RBF support vector machine on such wide data. Furthermore we know that the intrinsic dimensionality of the data is much lower than 4096 since all pictures of human faces look somewhat alike. The samples lie on a manifold of much lower dimension (say around 200 for instance). The PCA algorithm can be used to linearly transform the data while both reducing the dimensionality and preserve most of the explained variance at the same time. The class PCA used with the optional parameter is very useful in that case: since we are going to drop most of the singular vectors it is much more efficient to limit the computation to an approximated estimate of the singular vectors we will keep to actually perform the transform. For instance, the following shows 16 sample portraits (centered around 0.0) from the Olivetti dataset. On the right hand side are the first 16 singular vectors reshaped as portraits. Since we only require the top 16 singular vectors of a dataset with size and , the computation time is less than 1s: If we note and , the time complexity of the randomized PCA is instead of for the exact method implemented in PCA . The memory footprint of randomized PCA is also proportional to instead of for the exact method. Note: the implementation of in PCA with is not the exact inverse transform of even when (default). Examples: Faces recognition example using eigenfaces and SVMs Faces dataset decompositions References: “Finding structure with randomness: Stochastic algorithms for constructing approximate matrix decompositions” Halko, et al., 2009 2.5.1.4. Kernel PCA  KernelPCA is an extension of PCA which achieves non-linear dimensionality reduction through the use of kernels (see Pairwise metrics, Affinities and Kernels ). It has many applications including denoising, compression and structured prediction (kernel dependency estimation). KernelPCA supports both and . Examples: Kernel PCA 2.5.1.5. Sparse principal components analysis (SparsePCA and MiniBatchSparsePCA)  SparsePCA is a variant of PCA, with the goal of extracting the set of sparse components that best reconstruct the data. Mini-batch sparse PCA ( MiniBatchSparsePCA ) is a variant of SparsePCA that is faster but less accurate. The increased speed is reached by iterating over small chunks of the set of features, for a given number of iterations. Principal component analysis ( PCA ) has the disadvantage that the components extracted by this method have exclusively dense expressions, i.e. they have non-zero coefficients when expressed as linear combinations of the original variables. This can make interpretation difficult. In many cases, the real underlying components can be more naturally imagined as sparse vectors; for example in face recognition, components might naturally map to parts of faces. Sparse principal components yields a more parsimonious, interpretable representation, clearly emphasizing which of the original features contribute to the differences between samples. The following example illustrates 16 components extracted using sparse PCA from the Olivetti faces dataset. It can be seen how the regularization term induces many zeros. Furthermore, the natural structure of the data causes the non-zero coefficients to be vertically adjacent. The model does not enforce this mathematically: each component is a vector , and there is no notion of vertical adjacency except during the human-friendly visualization as 64x64 pixel images. The fact that the components shown below appear local is the effect of the inherent structure of the data, which makes such local patterns minimize reconstruction error. There exist sparsity-inducing norms that take into account adjacency and different kinds of structure; see [Jen09] for a review of such methods. For more details on how to use Sparse PCA, see the Examples section, below. Note that there are many different formulations for the Sparse PCA problem. The one implemented here is based on [Mrl09] . The optimization problem solved is a PCA problem (dictionary learning) with an penalty on the components: \[\begin{split}(U^*, V^*)  \underset{U, V}{\operatorname{arg\,min\,}} & \frac{1}{2} ||X-UV||_2^2+\alpha||V||_1 \\ \text{subject to } & ||U_k||_2  1 \text{ for all } 0 \leq k < n_{components}\end{split}\] The sparsity-inducing norm also prevents learning components from noise when few training samples are available. The degree of penalization (and thus sparsity) can be adjusted through the hyperparameter . Small values lead to a gently regularized factorization, while larger values shrink many coefficients to zero. Note While in the spirit of an online algorithm, the class MiniBatchSparsePCA does not implement because the algorithm is online along the features direction, not the samples direction. Examples: Faces dataset decompositions References: Mrl09 “Online Dictionary Learning for Sparse Coding” J. Mairal, F. Bach, J. Ponce, G. Sapiro, 2009 Jen09 “Structured Sparse Principal Component Analysis” R. Jenatton, G. Obozinski, F. Bach, 2009 